# -*- coding: utf-8 -*-
"""hw_10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NlCioBtxeK7AV7pJTz1S5QW1NZoFixsP

## 1. Інсталювати та імпортувати необхідні бібліотеки. Необхідно буде інсталювати такі пакети
"""

!pip install ipykernel==5.5.6

!pip install plotly==5.20.0 "jupyterlab>=3" "ipywidgets>=7.6" --no-deps

!pip install "jupyterlab>=3" "ipywidgets>=7.6"

"""## 2. Завантажити дані з набору https://www.kaggle.com/datasets/unsdsn/world-happiness."""

!wget -O WorldHappinessReport.zip https://github.com/goitacademy/NUMERICAL-PROGRAMMING-IN-PYTHON/blob/main/WorldHappinessReport.zip?raw=true

"""## 3. Розпакувати дані"""

!unzip WorldHappinessReport.zip

"""## 4. Прочитати дані та відобразити загальну інформацію про статистики та типи ознак."""

import pandas as pd

# Завантаження всіх файлів та об'єднання їх в один DataFrame
files = ['2015.csv', '2016.csv', '2017.csv', '2018.csv', '2019.csv']
data = pd.concat([pd.read_csv(f) for f in files], ignore_index=True)

# Відображення загальної інформації про об'єднаний набір даних
data.info()
data.describe()

"""## 5. Побудувати діаграми розподілу числових ознак. Проаналізувати на відповідність чи не відповідність нормальному розподілу."""

import matplotlib.pyplot as plt
import seaborn as sns

# Визначення розміру для фігури
plt.figure(figsize=(15, 20))

# Перебір кожного числового стовпця та побудова гістограм
numeric_columns = data.select_dtypes(include=['float64', 'int64']).columns

for i, column in enumerate(numeric_columns, 1):
    plt.subplot(len(numeric_columns) // 3 + 1, 3, i)
    sns.histplot(data[column], kde=True)
    plt.title(f'Distribution of {column}')
    plt.xlabel(column)
    plt.ylabel('Frequency')

plt.tight_layout()
plt.show()

"""## 6. Виходячи із розуміння домену та даних відібрати певну кількість числових ознак та відобразити кореляційну матрицю"""

import matplotlib.pyplot as plt
import seaborn as sns

# Вибір значущих ознак для кореляційного аналізу
selected_columns = ['Happiness Score', 'Economy (GDP per Capita)', 'Family',
                    'Health (Life Expectancy)', 'Freedom', 'Trust (Government Corruption)',
                    'Generosity', 'Dystopia Residual']

# Створення кореляційної матриці для вибраних ознак
correlation_matrix = data[selected_columns].corr()

# Відображення кореляційної матриці
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', vmin=-1, vmax=1)
plt.title('Correlation Matrix of Selected Features')
plt.show()

"""## 7. Зробити висновок про наявність та силу лінійного зв'язку між ознаками.

### Виходячи з кореляційної матриці, можна зробити висновки про наявність і силу лінійного зв'язку між вибраними ознаками та Happiness Score. Ось основні спостереження:

1. Сильний лінійний зв'язок з Happiness Score:

  - Economy (GDP per Capita) (коефіцієнт кореляції 0.78): Це свідчить про сильний прямий зв'язок між рівнем економічного добробуту і рівнем щастя. Чим вище економічний добробут у країні, тим щасливішими зазвичай є її громадяни.
  - Health (Life Expectancy) (0.73): Високий рівень життя і тривалість життя також сильно пов'язані з рівнем щастя. Люди в країнах з вищою очікуваною тривалістю життя, як правило, щасливіші.
  - Family (0.69): Підтримка сім'ї має сильний вплив на рівень щастя. Ця ознака також добре корелює з Happiness Score, що показує важливість соціальної підтримки.
2. Середній лінійний зв'язок з Happiness Score:

  - Freedom (0.56): Свобода вибору і дій має позитивний, але середній зв'язок з рівнем щастя. Це вказує на те, що свобода є значущим, але не найсильнішим фактором впливу на щастя.
  - Trust (Government Corruption) (0.4): Хоча довіра до уряду та низький рівень корупції позитивно впливають на щастя, цей зв'язок є помірним. Це може свідчити про те, що інші фактори мають більший вплив на рівень щастя, хоча низький рівень корупції також важливий.
3. Слабкий лінійний зв'язок з Happiness Score:

  - Generosity (0.17): Альтруїзм і благодійність мають слабкий зв'язок з рівнем щастя. Це може бути пов'язано з тим, що щастя відчувається більше на індивідуальному рівні, а не обов’язково на рівні суспільства. Generosity, можливо, більш важливий на особистому рівні, ніж як національний показник.
  - Dystopia Residual (0.53): Цей показник має середній зв'язок з Happiness Score. Він часто використовується як базова оцінка, яка усуває негативні ефекти інших факторів, тому він може бути корисним для порівняння, але не є головним визначником рівня щастя.

###Загальний висновок

- Рівень щастя в значній мірі визначається економічними, соціальними та здоров'яними факторами, такими як Economy (GDP per Capita), Health (Life Expectancy) і Family. Інші фактори, як-от Freedom і Trust (Government Corruption), також роблять внесок, але в меншій мірі. Generosity має слабкий лінійний зв'язок з рівнем щастя, що вказує на те, що альтруїзм менш важливий на національному рівні для визначення щастя.

- Отже, найсильніші лінійні зв’язки спостерігаються між рівнем щастя та економічними і соціальними факторами. Це означає, що для покращення рівня щастя на рівні країни найбільше значення мають економічний розвиток, підтримка здоров'я і соціальна підтримка.

## 8. Відобразити розподіл цільової ознаки (Happiness.Score або Happiness.Rank) за країнами. Використовуючи наведений нижче код для побудови теплової мапи.
"""

import plotly.express as px

# Використання вашого DataFrame з даними
fig = px.choropleth(data,
                    locations="Country",
                    color="Happiness Score",
                    locationmode="country names",
                    color_continuous_scale="Viridis")

# Налаштування заголовка
fig.update_layout(title="Happiness Index by Country")

# Відображення графіка
fig.show()

"""## 9. Застосувати стандартизацію даних для приведення всіх значень до одного діапазону статистик. Використовуючи функцію data_scale() та наступні перетворення"""

import pandas as pd

# Вибираємо лише числові стовпці для стандартизації
numeric_data = data.select_dtypes(include=['float64', 'int64'])

# Визначення функції для стандартизації
def data_scale(data, scaler_type='minmax'):
    from sklearn.preprocessing import MinMaxScaler
    from sklearn.preprocessing import StandardScaler
    from sklearn.preprocessing import Normalizer

    if scaler_type == 'minmax':
        scaler = MinMaxScaler()
    elif scaler_type == 'std':
        scaler = StandardScaler()
    elif scaler_type == 'norm':
        scaler = Normalizer()

    scaler.fit(data)
    res = scaler.transform(data)
    return res

# Видалення стовпців з нульовим стандартним відхиленням після заповнення пропусків
numeric_data_filled = numeric_data.fillna(numeric_data.mean())
numeric_data_filtered = numeric_data_filled.loc[:, numeric_data_filled.std() > 1e-10]  # Фільтруємо стовпці з дуже малим std

# Застосування стандартизації до відфільтрованих даних
data_scaled = data_scale(numeric_data_filtered, scaler_type='std')
df_scaled = pd.DataFrame(data_scaled, columns=numeric_data_filtered.columns)

# Видалення стовпців, у яких залишаються значення, близькі до нуля після стандартизації
df_scaled = df_scaled.loc[:, (df_scaled.abs().sum() > 1e-10)]

# Відображення перших рядків очищених даних
print(df_scaled.head())

"""## 10. Відобразити статистики отриманого стандартизованого набору даних та порівняти зі статистиками оригінального набору даних. Зробити висновки."""

# Статистики оригінального набору даних (перед стандартизацією)
original_stats = numeric_data.describe()

# Статистики стандартизованого набору даних
scaled_stats = df_scaled.describe()

# Відображення статистик для порівняння
print("Статистики оригінального набору даних:")
print(original_stats)

print("\nСтатистики стандартизованого набору даних:")
print(scaled_stats)

"""## 11. Побудувати модель кластеризації засобами функції GaussianMixture() бібліотеки sklearn."""

from sklearn.mixture import GaussianMixture
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import seaborn as sns

# Вибір більше ознак для кластеризації
selected_features = ['Happiness Score', 'Happiness Rank', 'Economy (GDP per Capita)',
                     'Family', 'Health (Life Expectancy)', 'Freedom', 'Generosity', 'Trust (Government Corruption)']

# Стандартизація обраних ознак
df_selected = df_scaled[selected_features]

# Ініціалізація моделі Gaussian Mixture з більшою кількістю кластерів
n_clusters = 5
gmm = GaussianMixture(n_components=n_clusters, random_state=0)

# Навчання та прогнозування кластерів
gmm.fit(df_selected)
labels_gmm = gmm.predict(df_selected)

# Додавання міток кластерів до DataFrame для Gaussian Mixture
df_selected['Cluster_GMM'] = labels_gmm

# Ініціалізація KMeans з тією ж кількістю кластерів
kmeans = KMeans(n_clusters=n_clusters, random_state=0)
kmeans.fit(df_selected)
labels_kmeans = kmeans.predict(df_selected)

# Додавання міток кластерів до DataFrame для KMeans
df_selected['Cluster_KMeans'] = labels_kmeans

# Візуалізація результатів кластеризації на основі двох ознак
plt.figure(figsize=(14, 6))

# Графік для Gaussian Mixture
plt.subplot(1, 2, 1)
sns.scatterplot(x=df_selected['Happiness Score'], y=df_selected['Economy (GDP per Capita)'], hue=labels_gmm, palette='viridis')
plt.title("Gaussian Mixture Clustering")
plt.xlabel('Happiness Score')
plt.ylabel('Economy (GDP per Capita)')
plt.legend(title="Cluster")

# Графік для KMeans
plt.subplot(1, 2, 2)
sns.scatterplot(x=df_selected['Happiness Score'], y=df_selected['Economy (GDP per Capita)'], hue=labels_kmeans, palette='viridis')
plt.title("KMeans Clustering")
plt.xlabel('Happiness Score')
plt.ylabel('Economy (GDP per Capita)')
plt.legend(title="Cluster")

plt.tight_layout()
plt.show()

"""## 12. Побудувати теплову мапу для відображення розподілу країн за кластерами."""

import plotly.express as px

# Додаємо до DataFrame колонку з мітками кластерів
data['Cluster'] = labels_kmeans  # або labels_gmm

# Створюємо теплову мапу розподілу країн за кластерами
fig = px.choropleth(data,
                    locations="Country",
                    locationmode="country names",
                    color="Cluster",
                    color_continuous_scale="Viridis",
                    title="Distribution of Countries by Clusters")

fig.update_geos(showcoastlines=True, coastlinecolor="Black", showland=True, landcolor="LightGray")
fig.update_layout(coloraxis_colorbar=dict(title="Cluster"))
fig.show()

"""## 13. Дослідити вплив різного набору ознак на результат кластеризації."""

from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
import plotly.express as px

# Приклад наборів ознак
features_sets = {
    "economic": ["Economy (GDP per Capita)", "GDP per capita"],
    "social": ["Family", "Generosity", "Social support"],
    "mixed": ["Economy (GDP per Capita)", "Family", "Health (Life Expectancy)", "Freedom"]
}

# Проведення кластеризації для кожного набору ознак
results = {}
for name, features in features_sets.items():
    X = data[features].copy()
    X = X.fillna(X.mean())  # Заповнюємо пропуски середнім значенням

    # Перевіряємо, що є дані для кластеризації
    if X.empty or X.shape[0] < 3:
        print(f"Недостатньо даних для набору ознак {name}. Пропускаємо.")
        continue

    # Використовуємо KMeans для прикладу
    kmeans = KMeans(n_clusters=3, random_state=0).fit(X)
    labels_kmeans = kmeans.labels_

    # Зберігаємо результати
    results[name] = labels_kmeans

    # Додаємо результати кластеризації до початкового DataFrame
    data[f'Cluster_{name}'] = labels_kmeans

    # Побудова теплової мапи
    fig = px.choropleth(data,
                        locations="Country",
                        locationmode="country names",
                        color=f"Cluster_{name}",
                        title=f"Distribution of Countries by Clusters ({name} features)")
    fig.show()

"""## 14. Зробити загальний висновок про відповідність результатів кластеризації оригінальному розподілу країн за ознакою

### На основі результатів кластеризації, можна зробити декілька загальних висновків про відповідність отриманих кластерів оригінальному розподілу країн за ознаками:

1. Економічні ознаки: Використання лише економічних ознак, таких як ВВП на душу населення, створило кластери, які майже не відображають значущих відмінностей між країнами. Це може свідчити про те, що однієї економічної характеристики недостатньо для повної класифікації країн, зважаючи на те, що інші аспекти, такі як соціальні та політичні фактори, мають великий вплив на загальне щастя та розвиток.

2. Соціальні ознаки: При кластеризації на основі соціальних характеристик, таких як підтримка соціуму, відзначаються більш виражені відмінності між країнами. Ці кластери краще відображають соціальні розбіжності між країнами та можуть показувати розподіл країн за рівнем соціальної підтримки та якості життя.

3. Змішані ознаки: Комбінування економічних та соціальних ознак призвело до формування найбільш збалансованих кластерів. Це показує, що змішані показники є найбільш ефективними для класифікації країн, оскільки вони враховують декілька аспектів, що робить класифікацію більш комплексною і наближеною до реального стану.

4. Відповідність оригінальному розподілу: Загалом, найбільш точним підходом є використання змішаних ознак, оскільки цей підхід надає найбільш повну картину щодо відмінностей між країнами. Він відображає реальний розподіл країн на основі різноманітних характеристик, зокрема соціальних та економічних, що відповідає оригінальному розподілу за різними показниками щастя.

###Таким чином, для отримання більш точних результатів кластеризації рекомендується використовувати змішані ознаки, що враховують як економічні, так і соціальні фактори. Це дозволяє більш адекватно відобразити особливості кожної країни та відповідно до цього їх класифікувати.
"""