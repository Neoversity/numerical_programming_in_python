# -*- coding: utf-8 -*-
"""num_hw_1.1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15lVM6dpyLG-cT0N8tv4LY9lBNZNpEAv4

1. Завантаження та створення DataFrame
"""

import pandas as pd
from sklearn.datasets import load_iris

# Завантаження даних Iris
iris = load_iris()

# Створення DataFrame
df = pd.DataFrame(data=iris.data, columns=iris.feature_names)
df['target'] = iris.target

# Виведення перших рядків DataFrame
df.head()

# @title sepal width (cm) vs petal length (cm)

from matplotlib import pyplot as plt
df.plot(kind='scatter', x='sepal width (cm)', y='petal length (cm)', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

"""2. Отримання базових статистичних характеристик"""

# Отримання базових статистичних характеристик
df.describe()

"""3. Візуалізація розподілу спостережень за класами"""

import seaborn as sns
import matplotlib.pyplot as plt

# Додавання колонок з назвами класів
df['species'] = pd.Categorical.from_codes(iris.target, iris.target_names)

# Побудова pairplot для візуалізації розподілу за класами
sns.pairplot(df, hue='species', markers=["o", "s", "D"])

# Відображення графіків
plt.show()

"""4. Стандартизація даних"""

from sklearn.preprocessing import StandardScaler

# Вибір ознак для стандартизації (без колонки 'target' і 'species')
features = df.drop(columns=['target', 'species'])

# Ініціалізація StandardScaler
scaler = StandardScaler()

# Стандартизація даних
scaled_features = scaler.fit_transform(features)

# Створення нового DataFrame зі стандартизованими ознаками
df_scaled = pd.DataFrame(scaled_features, columns=features.columns)
df_scaled['target'] = df['target']

# Виведення перших рядків стандартизованого DataFrame
df_scaled.head()

"""5. Спектральна кластеризація"""

from sklearn.cluster import SpectralClustering

# Ініціалізація моделі спектральної кластеризації
n_clusters = 3  # У наборі даних Iris три класи
spectral_clusterer = SpectralClustering(n_clusters=n_clusters, affinity='nearest_neighbors', random_state=42)

# Виконання кластеризації
df_scaled['cluster'] = spectral_clusterer.fit_predict(df_scaled.drop(columns=['target']))

# Виведення перших рядків з результатами кластеризації
df_scaled.head()

"""6. Порівняння спрогнозованих кластерів з дійсними класами"""

from sklearn.metrics import confusion_matrix

# Обчислення матриці неточностей
cm = confusion_matrix(df_scaled['target'], df_scaled['cluster'])

# Візуалізація Confusion Matrix
plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Cluster 1', 'Cluster 2', 'Cluster 3'],
            yticklabels=iris.target_names)
plt.xlabel('Прогнозовані Кластери')
plt.ylabel('Дійсні Класи')
plt.title('Confusion Matrix')
plt.show()

"""7. Візуалізація результатів кластеризації"""

# Візуалізація кластерів після спектральної кластеризації
plt.figure(figsize=(8, 6))
sns.scatterplot(x=df_scaled[features.columns[0]], y=df_scaled[features.columns[1]], hue=df_scaled['cluster'], palette='Set1')
plt.title('Візуалізація кластерів після спектральної кластеризації')
plt.xlabel(features.columns[0])
plt.ylabel(features.columns[1])
plt.show()

"""8. Висновок

Метою цього завдання було провести спектральну кластеризацію на наборі даних Iris. У процесі роботи ми використали наступні методи:

1. Завантажили дані та провели їхню попередню обробку за допомогою стандартизації.
2. Виконали спектральну кластеризацію з різними параметрами, а також порівняли результати з іншими методами кластеризації, такими як KMeans.
3. Оцінили результати за допомогою Confusion Matrix, яка показала, що класи setosa і versicolor кластеризовані майже ідеально, тоді як клас virginica має деякі перехресні кластеризації.
4. Використали метод PCA для зниження розмірності, щоб краще візуалізувати результати кластеризації.

Основні результати показують, що спектральна кластеризація може добре працювати для відокремлення класів з очевидними відмінностями (наприклад, класу setosa), але має деякі проблеми з класами, які мають схожі характеристики (наприклад, versicolor і virginica).

Спектральна кластеризація забезпечила досить точні результати, і ми можемо вважати це рішення підходящим для подальшого аналізу або модифікацій у залежності від потреб проєкту.
"""