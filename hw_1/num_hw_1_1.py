# -*- coding: utf-8 -*-
"""num_hw_1.1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15lVM6dpyLG-cT0N8tv4LY9lBNZNpEAv4

1. Завантаження та створення DataFrame
"""

import pandas as pd
from sklearn.datasets import load_iris

# Завантаження даних Iris
iris = load_iris()

# Створення DataFrame
df = pd.DataFrame(data=iris.data, columns=iris.feature_names)
df['target'] = iris.target

# Виведення перших рядків DataFrame
df.head()

# @title sepal width (cm) vs petal length (cm)

from matplotlib import pyplot as plt
df.plot(kind='scatter', x='sepal width (cm)', y='petal length (cm)', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

"""2. Отримання базових статистичних характеристик"""

# Отримання базових статистичних характеристик
df.describe()

"""3. Візуалізація розподілу спостережень за класами"""

import seaborn as sns
import matplotlib.pyplot as plt

# Додавання колонок з назвами класів
df['species'] = pd.Categorical.from_codes(iris.target, iris.target_names)

# Побудова pairplot для візуалізації розподілу за класами
sns.pairplot(df, hue='species', markers=["o", "s", "D"])

# Відображення графіків
plt.show()

"""4. Стандартизація даних"""

from sklearn.preprocessing import StandardScaler

# Вибір ознак для стандартизації (без колонки 'target' і 'species')
features = df.drop(columns=['target', 'species'])

# Ініціалізація StandardScaler
scaler = StandardScaler()

# Стандартизація даних
scaled_features = scaler.fit_transform(features)

# Створення нового DataFrame зі стандартизованими ознаками
df_scaled = pd.DataFrame(scaled_features, columns=features.columns)
df_scaled['target'] = df['target']

# Виведення перших рядків стандартизованого DataFrame
df_scaled.head()

"""5. Спектральна кластеризація"""

from sklearn.cluster import SpectralClustering

# Ініціалізація моделі спектральної кластеризації
n_clusters = 3  # У наборі даних Iris три класи
spectral_clusterer = SpectralClustering(n_clusters=n_clusters, affinity='nearest_neighbors', random_state=42)

# Виконання кластеризації
df_scaled['cluster'] = spectral_clusterer.fit_predict(df_scaled.drop(columns=['target']))

# Виведення перших рядків з результатами кластеризації
df_scaled.head()

"""6. Порівняння спрогнозованих кластерів з дійсними класами"""

from sklearn.metrics import confusion_matrix

# Обчислення матриці неточностей
cm = confusion_matrix(df_scaled['target'], df_scaled['cluster'])

# Візуалізація Confusion Matrix
plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Cluster 1', 'Cluster 2', 'Cluster 3'],
            yticklabels=iris.target_names)
plt.xlabel('Прогнозовані Кластери')
plt.ylabel('Дійсні Класи')
plt.title('Confusion Matrix')
plt.show()

"""7. Візуалізація результатів кластеризації"""

# Візуалізація кластерів після спектральної кластеризації
plt.figure(figsize=(8, 6))
sns.scatterplot(x=df_scaled[features.columns[0]], y=df_scaled[features.columns[1]], hue=df_scaled['cluster'], palette='Set1')
plt.title('Візуалізація кластерів після спектральної кластеризації')
plt.xlabel(features.columns[0])
plt.ylabel(features.columns[1])
plt.show()

"""код з додаванням KMeans"""

from sklearn.cluster import KMeans

# Ініціалізація моделі KMeans
kmeans_clusterer = KMeans(n_clusters=3, random_state=42)

# Виконання кластеризації KMeans
df_scaled['kmeans_cluster'] = kmeans_clusterer.fit_predict(df_scaled.drop(columns=['target']))

# Порівняння спрогнозованих кластерів від KMeans та дійсних класів
from sklearn.metrics import confusion_matrix

# Обчислення матриці неточностей для KMeans
cm_kmeans = confusion_matrix(df_scaled['target'], df_scaled['kmeans_cluster'])

# Візуалізація Confusion Matrix для KMeans
plt.figure(figsize=(6, 4))
sns.heatmap(cm_kmeans, annot=True, fmt='d', cmap='Blues', xticklabels=['Cluster 1', 'Cluster 2', 'Cluster 3'],
            yticklabels=iris.target_names)
plt.xlabel('Прогнозовані Кластери (KMeans)')
plt.ylabel('Дійсні Класи')
plt.title('Confusion Matrix для KMeans')
plt.show()

# Візуалізація кластерів після KMeans кластеризації
plt.figure(figsize=(8, 6))
sns.scatterplot(x=df_scaled[features.columns[0]], y=df_scaled[features.columns[1]], hue=df_scaled['kmeans_cluster'], palette='Set1')
plt.title('Візуалізація кластерів після KMeans кластеризації')
plt.xlabel(features.columns[0])
plt.ylabel(features.columns[1])
plt.show()

"""8. Висновок

Метою цього завдання було провести кластеризацію на наборі даних Iris та порівняти результати двох методів — спектральної кластеризації та KMeans. У процесі роботи ми використали наступні підходи:

1. Завантаження та попередня обробка даних: Ми завантажили дані Iris і стандартизували їх за допомогою StandardScaler для підготовки до кластеризації.

2. Спектральна кластеризація:

- Ми застосували спектральну кластеризацію з різними параметрами та проаналізували результати за допомогою Confusion Matrix.
Кластеризація показала, що клас setosa був майже ідеально відокремлений, тоді як класи versicolor і virginica мали деякі перехресні кластеризації.
3. KMeans кластеризація:

- Ми порівняли результати спектральної кластеризації з методом KMeans. Результати KMeans виявились дуже схожими: клас setosa також кластеризувався ідеально, а класи versicolor і virginica мали перехресну кластеризацію.
4. Оцінка результатів:

- Обидва методи продемонстрували високу точність для класифікації класів з чіткими відмінностями (особливо setosa), але зіткнулись з труднощами під час кластеризації класів versicolor і virginica, які мають схожі характеристики.

Основні результати показують, що обидва методи — спектральна кластеризація та KMeans — добре підходять для вирішення завдань кластеризації на наборі даних Iris, але кожен з них має певні обмеження при класифікації класів з подібними ознаками.
"""